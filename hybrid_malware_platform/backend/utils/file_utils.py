import os, io, json, hashlib, time
import magic  # from python-magic-bin on Windows
from werkzeug.utils import secure_filename

# 50 MB limit by default
MAX_BYTES = 50 * 1024 * 1024

# Allow-list by extension (expand later)
ALLOWED_EXTS = {
    ".exe", ".dll", ".sys", ".bin", ".apk", ".dex", ".jar",
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".rtf", ".js", ".vbs", ".ps1", ".hta"
}

def _hash_stream(stream: io.BufferedReader, algo="sha256"):
    h = hashlib.new(algo)
    stream.seek(0)
    for chunk in iter(lambda: stream.read(1024 * 1024), b""):
        h.update(chunk)
    stream.seek(0)
    return h.hexdigest()

def hash_bytes(b: bytes, algo="sha256"):
    return hashlib.new(algo, b).hexdigest()

def validate_extension(filename: str) -> bool:
    ext = os.path.splitext(filename)[1].lower()
    return ext in ALLOWED_EXTS

def detect_mime(file_path: str) -> str:
    try:
        return magic.from_file(file_path, mime=True) or "application/octet-stream"
    except Exception:
        return "application/octet-stream"

def safe_save_upload(file_storage, dst_dir: str):
    """
    Saves the uploaded file into dst_dir using a SHA256 filename, plus a metadata .json.
    Returns dict with: {sha256, md5, size, stored_path, meta_path, orig_name, mime}
    """
    os.makedirs(dst_dir, exist_ok=True)

    # size check (streaming safe)
    file_storage.stream.seek(0, os.SEEK_END)
    size = file_storage.stream.tell()
    file_storage.stream.seek(0)
    if size <= 0 or size > MAX_BYTES:
        raise ValueError(f"Invalid size: {size} bytes (limit {MAX_BYTES})")

    # extension allow-list
    orig_name = secure_filename(file_storage.filename or "upload.bin")
    if not validate_extension(orig_name):
        raise ValueError("Extension not allowed")

    # read into memory once for hashing (fits 50 MB)
    data = file_storage.read()
    file_storage.stream.seek(0)

    sha256 = hash_bytes(data, "sha256")
    md5    = hash_bytes(data, "md5")

    # final path based on hash
    base = sha256
    stored_path = os.path.join(dst_dir, base)
    # avoid collisions (ext optional, we keep raw hash file)
    if os.path.exists(stored_path):
        # exact dup; okay to re-use the same object
        pass
    else:
        with open(stored_path, "wb") as f:
            f.write(data)

    # detect MIME on disk
    mime = detect_mime(stored_path)

    # metadata
    meta = {
        "sha256": sha256,
        "md5": md5,
        "size": size,
        "mime": mime,
        "orig_name": orig_name,
        "stored_name": base,
        "stored_path": stored_path.replace("\\", "/"),
        "uploaded_at": int(time.time())
    }
    meta_path = stored_path + ".json"
    with open(meta_path, "w", encoding="utf-8") as f:
        json.dump(meta, f, indent=2)

    return {
        **meta,
        "meta_path": meta_path.replace("\\", "/")
    }
